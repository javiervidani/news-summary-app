"""
Provider Factory for creating new news source providers.
Handles discovery, generation, testing, and registration of new sources.
"""

import logging
import os
import json
import importlib
import asyncio
import re
import requests
from pathlib import Path
from typing import Dict, Any, Tuple, List, Optional, Union

# We'll implement a simple LLM client here
# In a real implementation, you'd use a more sophisticated client
from .llm_client import LLMClient

logger = logging.getLogger(__name__)

class ProviderFactory:
    """Factory for creating and managing provider modules."""
    
    def __init__(self):
        """Initialize the provider factory."""
        logger.info("Initializing Provider Factory")
        
        # Initialize LLM client
        self.llm_client = LLMClient()
        
        # Set up paths
        self.project_root = Path(os.path.dirname(os.path.dirname(__file__)))
        self.templates_dir = self.project_root / "agent" / "templates"
        self.providers_dir = self.project_root / "providers"
        self.config_dir = self.project_root / "config"
        
        # Load templates
        self.templates = self._load_templates()
        
    def _load_templates(self) -> Dict[str, str]:
        """Load provider templates."""
        templates = {}
        
        # Check if templates directory exists
        if not self.templates_dir.exists():
            logger.warning(f"Templates directory not found: {self.templates_dir}")
            # Create default templates
            self._create_default_templates()
            
        # Load templates from directory
        for template_file in self.templates_dir.glob("*.py"):
            try:
                with open(template_file, 'r') as f:
                    template_name = template_file.stem
                    templates[template_name] = f.read()
                    logger.debug(f"Loaded template: {template_name}")
            except Exception as e:
                logger.error(f"Error loading template {template_file}: {e}")
                
        return templates
    
    def _create_default_templates(self):
        """Create default templates if they don't exist."""
        logger.info("Creating default templates")
        
        # Create templates directory if it doesn't exist
        self.templates_dir.mkdir(exist_ok=True, parents=True)
        
        # Create RSS template
        rss_template = """
'''
{provider_name} news RSS provider.
Fetches articles from {provider_name}.
Generated by MCP Provider Factory.
'''

import logging
import requests
import feedparser
from typing import List, Dict, Any
from bs4 import BeautifulSoup

from .base_provider import BaseProvider


class {class_name}Provider(BaseProvider):
    '''RSS feed provider for {provider_name}.'''
    
    def __init__(self, config: Dict[str, Any]):
        super().__init__(config)
        self.logger = logging.getLogger(__name__)
        self.rss_url = config.get('url', '{feed_url}')
        self.topics = config.get('topics', ['general'])
    
    def fetch_articles(self) -> List[Dict[str, Any]]:
        '''Fetch articles from {provider_name} RSS feed.'''
        articles = []
        
        try:
            self.logger.info(f"Fetching {provider_name} RSS from {self.rss_url}")
            
            # Fetch RSS feed
            response = requests.get(self.rss_url, timeout=30)
            response.raise_for_status()
            
            # Parse RSS feed
            feed = feedparser.parse(response.content)
            
            for entry in feed.entries:
                try:
                    article = self._parse_entry(entry)
                    if article:
                        articles.append(article)
                except Exception as e:
                    self.logger.warning(f"Error parsing {provider_name} entry: {e}")
                    continue
            
            self.logger.info(f"Successfully fetched {len(articles)} articles from {provider_name}")
            return articles
            
        except requests.RequestException as e:
            self.logger.error(f"Error fetching {provider_name} RSS: {e}")
            return []
        except Exception as e:
            self.logger.error(f"Unexpected error fetching {provider_name} articles: {e}")
            return []
    
    def _parse_entry(self, entry) -> Dict[str, Any]:
        '''Parse a single RSS entry.'''
        title = entry.get('title', 'Untitled')
        url = entry.get('link', '')
        
        # Get description/summary
        content = entry.get('description', '')
        if entry.get('summary'):
            content = entry.summary
        
        # Clean HTML from content
        content = self._clean_html(content)
        
        # Determine topic from categories or URL
        topic = self._determine_topic(entry, url)
        
        return self.normalize_article(title, content, url, topic)
    
    def _clean_html(self, content: str) -> str:
        '''Remove HTML tags from content.'''
        if not content:
            return ""
        
        try:
            soup = BeautifulSoup(content, 'html.parser')
            return soup.get_text().strip()
        except Exception:
            return content
    
    def _determine_topic(self, entry, url: str) -> str:
        '''Determine article topic from categories or URL.'''
        # Check RSS entry tags/categories
        if hasattr(entry, 'tags') and entry.tags:
            for tag in entry.tags:
                tag_term = tag.get('term', '').lower()
                if any(topic in tag_term for topic in self.topics):
                    return tag_term
        
        # Default topic
        return 'general'


# Main function for the module
def fetch_articles() -> List[Dict[str, Any]]:
    '''Main entry point for the {provider_name} provider.'''
    # Default config - will be overridden by runner
    config = {
        'url': '{feed_url}',
        'topics': ['general']
    }
    
    provider = {class_name}Provider(config)
    return provider.fetch_articles()
"""
        
        # Save the template
        with open(self.templates_dir / "rss_provider.py", 'w') as f:
            f.write(rss_template.strip())
            
        logger.info("Created default RSS template")
        
    async def discover_feed(self, source_name: str) -> Optional[str]:
        """
        Find RSS feed URL for a news source.
        
        Args:
            source_name: Name of the news source
            
        Returns:
            URL of the discovered RSS feed, or None if not found
        """
        logger.info(f"Discovering RSS feed for {source_name}")
        
        # First try a direct approach using common patterns
        common_urls = [
            f"https://www.{source_name}.com/rss",
            f"https://{source_name}.com/rss",
            f"https://www.{source_name}.com/feed",
            f"https://{source_name}.com/feed",
            f"https://rss.{source_name}.com",
            f"https://{source_name}.com/rss/index.xml"
        ]
        
        for url in common_urls:
            try:
                logger.debug(f"Trying URL: {url}")
                response = requests.get(url, timeout=10)
                if response.status_code == 200:
                    content_type = response.headers.get('Content-Type', '')
                    if any(x in content_type.lower() for x in ['xml', 'rss', 'atom']):
                        logger.info(f"Found RSS feed for {source_name}: {url}")
                        return url
            except requests.RequestException:
                continue
                
        # If direct approach fails, use LLM to find the feed
        prompt = f"Find the main RSS feed URL for {source_name} news website. Return ONLY the URL, nothing else."
        
        try:
            response = await self.llm_client.generate(prompt)
            
            # Extract URL from response using regex
            url_pattern = r'https?://[^\s<>"\']+'
            matches = re.findall(url_pattern, response)
            
            if matches:
                candidate_url = matches[0]
                logger.info(f"LLM suggested URL for {source_name}: {candidate_url}")
                
                # Verify it's a valid RSS feed
                try:
                    response = requests.get(candidate_url, timeout=10)
                    if response.status_code == 200:
                        content_type = response.headers.get('Content-Type', '')
                        if any(x in content_type.lower() for x in ['xml', 'rss', 'atom']):
                            logger.info(f"Verified RSS feed for {source_name}: {candidate_url}")
                            return candidate_url
                except requests.RequestException:
                    pass
        except Exception as e:
            logger.error(f"Error using LLM to discover feed: {e}")
            
        logger.warning(f"Could not discover RSS feed for {source_name}")
        return None
        
    async def generate_provider(self, name: str, url: str) -> Tuple[bool, str]:
        """
        Generate provider code based on source.
        
        Args:
            name: Name of the news source
            url: URL of the news source RSS feed
            
        Returns:
            Tuple containing:
            - Success indicator (boolean)
            - Path to generated file or error message
        """
        logger.info(f"Generating provider for {name} with URL {url}")
        
        # Determine source type (assuming RSS for now)
        source_type = "rss"
        
        # Get the template
        template = self.templates.get('rss_provider')
        if not template:
            return False, "RSS template not found"
            
        # Create class name (capitalize words and remove spaces)
        class_name = ''.join(word.capitalize() for word in name.split())
        
        # Format the template
        try:
            provider_code = template.format(
                provider_name=name.capitalize(),
                class_name=class_name,
                feed_url=url
            )
            
            # Create file path
            file_name = name.lower().replace(' ', '_')
            file_path = self.providers_dir / f"{file_name}.py"
            
            # Write the file
            with open(file_path, 'w') as f:
                f.write(provider_code)
                
            logger.info(f"Provider file created: {file_path}")
            return True, str(file_path)
            
        except Exception as e:
            logger.error(f"Error generating provider code: {e}")
            return False, str(e)
        
    async def test_provider(self, name: str) -> Tuple[bool, List[Dict[str, Any]]]:
        """
        Test a provider by attempting to fetch articles.
        
        Args:
            name: Name of the provider to test
            
        Returns:
            Tuple containing:
            - Success indicator (boolean)
            - List of articles (if successful)
        """
        logger.info(f"Testing provider: {name}")
        
        # Import the provider module
        try:
            # Convert name to module format (lowercase, replace spaces with underscores)
            module_name = name.lower().replace(' ', '_')
            
            # Dynamically import the module
            module_path = f"providers.{module_name}"
            
            # Check if the module exists
            if not (self.providers_dir / f"{module_name}.py").exists():
                logger.error(f"Provider module not found: {module_path}")
                return False, []
                
            provider_module = importlib.import_module(module_path)
            
            # Test the fetch_articles function
            articles = provider_module.fetch_articles()
            
            if not articles:
                logger.warning(f"No articles found for provider: {name}")
                return False, []
                
            logger.info(f"Successfully fetched {len(articles)} articles from {name}")
            return True, articles
            
        except Exception as e:
            logger.error(f"Error testing provider {name}: {e}")
            return False, []
            
    async def register_provider(self, name: str, url: str) -> bool:
        """
        Add provider to config file.
        
        Args:
            name: Name of the provider
            url: URL of the provider's RSS feed
            
        Returns:
            Success indicator (boolean)
        """
        logger.info(f"Registering provider: {name}")
        
        try:
            # Load current providers
            providers_path = self.config_dir / "providers.json"
            
            with open(providers_path, 'r') as f:
                providers = json.load(f)
                
            # Convert name to key format (lowercase)
            key = name.lower().replace(' ', '_')
            
            # Add new provider
            providers[key] = {
                "module": key,
                "type": "rss",
                "url": url,
                "enabled": True,
                "topics": ["general"]
            }
            
            # Save updated config
            with open(providers_path, 'w') as f:
                json.dump(providers, f, indent=2)
                
            logger.info(f"Provider {name} registered successfully")
            return True
            
        except Exception as e:
            logger.error(f"Error registering provider {name}: {e}")
            return False
            
    async def unregister_provider(self, name: str) -> bool:
        """
        Remove provider from config file.
        
        Args:
            name: Name of the provider to remove
            
        Returns:
            Success indicator (boolean)
        """
        logger.info(f"Unregistering provider: {name}")
        
        try:
            # Load current providers
            providers_path = self.config_dir / "providers.json"
            
            with open(providers_path, 'r') as f:
                providers = json.load(f)
                
            # Convert name to key format (lowercase)
            key = name.lower().replace(' ', '_')
            
            # Check if provider exists
            if key not in providers:
                logger.warning(f"Provider {name} not found in configuration")
                return False
                
            # Remove provider
            del providers[key]
            
            # Save updated config
            with open(providers_path, 'w') as f:
                json.dump(providers, f, indent=2)
                
            logger.info(f"Provider {name} unregistered successfully")
            return True
            
        except Exception as e:
            logger.error(f"Error unregistering provider {name}: {e}")
            return False
